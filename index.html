<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>苍晨的技术博文</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="技术总结 记录 沉淀 积累">
<meta property="og:type" content="website">
<meta property="og:title" content="苍晨的技术博文">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="苍晨的技术博文">
<meta property="og:description" content="技术总结 记录 沉淀 积累">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苍晨的技术博文">
<meta name="twitter:description" content="技术总结 记录 沉淀 积累">
  
    <link rel="alternative" href="/atom.xml" title="苍晨的技术博文" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">苍晨的技术博文</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我走过脚印也曾留下，苍穹之下却渺如尘沙</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/01/24/js/" class="article-date">
  <time datetime="2016-01-24T11:08:22.000Z" itemprop="datePublished">2016-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/24/js/">javaScript 继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>引言：javascript是一门面向对象的语言，它的继承靠的是原型链来实现的。</p>
<h2 id="在javascript中原型链是什么？">在javascript中原型链是什么？</h2><p>理解原型链，从字面上很好理解，就是连接原型的一个链条。什么又是原型？什么事构造函数？什么是实例？,在javascript我们定义一个函数，这个函数就可以称之为原型。通过这个函数new出来的对象我们称为实例。 里Function有一个属性称为prototype. 每个构造函数都有一个原型对象，原型对象中含有一个指向构造函数的指针。</p>
<h3 id="继承实现实例1：">继承实现实例1：</h3><pre><code><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span>{
<span class="keyword">this</span>.sex=<span class="string">'male'</span>
}

<span class="function"><span class="keyword">function</span> <span class="title">Xiaoming</span>(<span class="params">name</span>)</span>{
<span class="keyword">this</span>.name=name;
}
Xiaoming.prototype=<span class="keyword">new</span> People();
Xiaoming.prototype.getSex=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
<span class="keyword">return</span> <span class="keyword">this</span>.sex;
}

<span class="keyword">var</span> instance=<span class="keyword">new</span> Xiaoming(<span class="string">'xiaoming'</span>);

<span class="built_in">console</span>.log(instance.getSex()+<span class="string">"--name--"</span>+instance.name);

<span class="comment">//输出‘male’ 'xiaoming'</span>
</code></pre><p>通过改变Xiaoming.prototype属性使得原本存在于父类中的方法都可以被子类共享。  </p>
<h3 id="继承实现实例2：">继承实现实例2：</h3><p>上面的例子通过原型构造链来实现，存在一个问题来看下面的例子：</p>
<pre><code>    <span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span>{
        <span class="keyword">this</span>.sex=<span class="string">'male'</span>
        <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
    }

    <span class="function"><span class="keyword">function</span> <span class="title">Xiaoming</span>(<span class="params">name</span>)</span>{
        <span class="keyword">this</span>.name=name;

    }

Xiaoming.prototype=<span class="keyword">new</span> People();

<span class="keyword">var</span> xiaohuang=<span class="keyword">new</span> Xiaoming(<span class="string">'123'</span>);
xiaohuang.list.push(<span class="number">5</span>);

<span class="built_in">console</span>.log(xiaohuang.list);<span class="comment">//[1,2,3,4,5]</span>

<span class="keyword">var</span> instance=<span class="keyword">new</span> Xiaoming();

<span class="built_in">console</span>.log(instance.list);<span class="comment">//[1,2,3,4,5]</span>
</code></pre><p>通过原型链来实现的继承，存在引用类型共享问题。我了解决这个问题我们使用 所谓的<strong>经典继承</strong>构造函数也是函数的一种我么可以采用 call,apply来进行调用父类的构造函数。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span>{
    <span class="keyword">this</span>.sex=<span class="string">'male'</span>
<span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
}

<span class="function"><span class="keyword">function</span> <span class="title">Xiaoming</span>(<span class="params">name</span>)</span>{
    People.call(<span class="keyword">this</span>)<span class="comment">//借用了 People的构造函数</span>
    <span class="keyword">this</span>.name=name;
}
<span class="keyword">var</span> xiaohuang=<span class="keyword">new</span> Xiaoming(<span class="string">'123'</span>);
xiaohuang.list.push(<span class="number">5</span>);<span class="comment">//[1,2,3,4,5]</span>
<span class="built_in">console</span>.log(xiaohuang.list);
<span class="keyword">var</span> instance=<span class="keyword">new</span> Xiaoming();<span class="comment">//[1,2,3,4]</span>
<span class="built_in">console</span>.log(instance.list);
</code></pre><h4 id="通过经典继承优点：通过借用构造函数的方式可以传递参数，缺点函数无法复用。">通过经典继承优点：通过借用构造函数的方式可以传递参数，缺点函数无法复用。</h4><pre><code><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">sex</span>)</span>{
    <span class="keyword">this</span>.sex=sex;
    <span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
}

<span class="function"><span class="keyword">function</span> <span class="title">Xiaoming</span>(<span class="params">name</span>)</span>{
    People.call(<span class="keyword">this</span>,<span class="string">'male'</span>)
    <span class="keyword">this</span>.name=name;
}
<span class="built_in">console</span>.log(instance.sex);
</code></pre><h3 id="组合继承">组合继承</h3><p>结合原型继承，和经典继承。所有子类共享父类的方法，通过经典继承，每个子类实例都有自己的属性，这种方式最常用。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">sex</span>)</span>{
    <span class="keyword">this</span>.sex=sex;
<span class="keyword">this</span>.list=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
}

People.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{

<span class="built_in">console</span>.log(<span class="keyword">this</span>.sex+<span class="string">"aa"</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">Xiaoming</span>(<span class="params">name</span>)</span>{
        People.call(<span class="keyword">this</span>,name)
    <span class="keyword">this</span>.name=name;

}

Xiaoming.prototype=<span class="keyword">new</span> People();
Xiaoming.prototype.constructor=Xiaoming;

<span class="keyword">var</span> instance=<span class="keyword">new</span> Xiaoming(<span class="string">'man'</span>);

<span class="built_in">console</span>.log(instance.sex); <span class="comment">//man</span>
instance.list.push(<span class="number">5</span>);
<span class="built_in">console</span>.log(instance.list);<span class="comment">//[1,2,3,4,5]</span>

instance.sayName();

<span class="keyword">var</span> instance2=<span class="keyword">new</span> Xiaoming(<span class="string">'gril'</span>);

<span class="built_in">console</span>.log(instance2.list);<span class="comment">//[1,2,3,4]</span>
</code></pre><h3 id="原型式继承">原型式继承</h3><p>道格拉斯-克罗克福德2006年提出：</p>
<p>通过如下函数：// IE9+ firfox4+ safari 5+ opera 12+ chrome;<br>缺点：引用类型值依然互相影响。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>{
    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>{};
    F.prototype=o;
    <span class="keyword">return</span> <span class="keyword">new</span> F();
}
</code></pre><p>实例：  </p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>{
      <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>{};
      F.prototype=o;
     <span class="keyword">return</span> <span class="keyword">new</span> F();
}

<span class="keyword">var</span> person={
      name:<span class="string">'test'</span>
      <span class="keyword">list</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]
}

<span class="keyword">var</span> instance=<span class="keyword">new</span> object(person);
instance.<span class="keyword">list</span>.push(<span class="number">6</span>);

console.log(instance.name);<span class="comment">//test</span>

<span class="keyword">var</span> instance2=<span class="keyword">new</span> object(person);

console.log(instance2.<span class="keyword">list</span>);<span class="comment">//[1,2,3,4,5,6]</span>
</code></pre><p>理解javascript函数原型，构造函数，原型链，能更好的理解继承。组合模式是javascript 中面向对象最常用的一种继承方式。</p>

      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2016/01/24/js/" data-id="cijsmg7u50003xfkqcmf00a5k" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/javaScript-继承/">javaScript 继承</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Angaular-digest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/11/20/Angaular-digest/" class="article-date">
  <time datetime="2015-11-20T12:33:15.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/11/20/Angaular-digest/">实现Angualrjs脏数据监测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Angular的不同点">Angular的不同点</h1><p>谷歌的Angular JS是一个非常强大优秀的前段框架，它颠覆了我们以往对前段的认识，以前说到前端首先想到jQuery去操作Dom元素，但在Angular中切都是数据为王。</p>
<h2 id="angular中是如何实现脏数据监测的？">angular中是如何实现脏数据监测的？</h2><p>我们需要用到的类库：lodash.js比较好用的js工具库，用它的目的仅仅是为了操作数组，Angular中并没有用到。<a href="https://github.com/lodash/lodash" target="_blank" rel="external">lodash 下载</a>  </p>
<p>loads的一些例子:</p>
<pre><code>var a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
var b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
var c= _.<span class="built_in">map</span>(a,function(i){  <span class="comment">// 迭代 map 中的每一元素，返回一个新的列表</span>
<span class="keyword">return</span> i*<span class="number">2</span>;
})

console.assert(a!==b);
console.assert(_.isEqual(a,b));
console.assert(_.isEqual([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>],c));
</code></pre><h1 id="循序渐进的造轮子">循序渐进的造轮子</h1><h2 id="版本1：创建一个全局的Scope作用域">版本1：创建一个全局的Scope作用域</h2><pre><code>/＊＊细节按照javascript的惯例 构造函数始终都应该方法名大写,而非构造函数则应该小写主要是为了区分ECMASScript中的其它函数

/＊＊什么才是构造函数？
    没有显示的创建对象
    直接将属性和方法赋给<span class="keyword">this</span> 对象
    没有<span class="keyword">return</span> 语句
    要创建构造函数的实例 必须使用 <span class="keyword">new</span> 操作符号
＊＊/


<span class="comment">//创建 Angular中的Scope</span>

<span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">()</span></span>{
}
<span class="keyword">var</span> scope=<span class="keyword">new</span> Scope();
scope.firstName=<span class="string">'jun'</span>
scope.lastName=<span class="string">'tom'</span>
</code></pre><p>为了监控Scope中的数据变化,我们需要给Scope中存在一个数组来保存scope中的元素</p>
<pre><code><span class="keyword">function</span> Scope(){
this.$<span class="variable">$watchers</span>=[]; //保存数据, 在Angualr中所有$$开头的变量都是私有
}
</code></pre><p>为了监控 $$watchers数组中的数据变化需要创建一个watch函数，使用原型构造链的方式创建</p>
<pre><code>Scope.prototype.<span class="variable">$watch</span>=<span class="keyword">function</span>(watchFn,listenerFn){
var watcher={
    watchFn:watchFn,
    listenerFn:listenerFn
};
this.$<span class="variable">$watchers</span>.push(watcher); //把传递过来的参数，封装为一个对象，入栈
}
</code></pre><p>创建一个$digest函数用于检测scope中的数据有没有变化，使用digest函数回调watch中的listenFn函数。</p>
<pre><code>    Scope.prototype.<span class="variable">$digest</span>=<span class="keyword">function</span>(){
    <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>,function(watch){ //lodash.js工具类中提供的遍历数组方法。
    watch.listenerFn();//回调
    })
}
</code></pre><p>测试：</p>
<pre><code>var scope=new Scope();
scope.<span class="variable">$watch</span>(
    <span class="keyword">function</span>(){console.log(<span class="string">'aa'</span>)},
    <span class="keyword">function</span>(){console.log(<span class="string">'listener'</span>)}
    )
scope.<span class="variable">$digest</span>();

输出：listener
</code></pre><h2 id="版本2：脏数据监测">版本2：脏数据监测</h2><pre><code><span class="keyword">function</span> Scope(){
this.$<span class="variable">$watchers</span>=[]; 
}

Scope.prototype.<span class="variable">$watch</span>=<span class="keyword">function</span>(watchFn,listenerFn){
var watcher={
    watchFn:watchFn,
    listenerFn:listenerFn
};
this.$<span class="variable">$watchers</span>.push(watcher);
}
</code></pre><p>上面这和版本一摸一样，变化的是$digest函数，添加一个比较功能：</p>
<pre><code>Scope.prototype.<span class="variable">$digest</span>=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> <span class="keyword">self</span>=this;
    _.<span class="keyword">forEach</span>(this.<span class="variable">$$watchers</span>,<span class="function"><span class="keyword">function</span><span class="params">(watch)</span></span>{
    <span class="keyword">var</span> newValue=watch.watchFn(<span class="keyword">self</span>); <span class="comment">//给把scope当作变量传递给watchFn,,获得这个scope的新        的value</span>
    <span class="keyword">var</span> oldValue=watch.last; <span class="comment">// 定义一个last变量 第一次值是undefined</span>
    <span class="keyword">if</span>(newValue !==oldValue){ <span class="comment">//新增的比较功能 ！＝＝为绝对相等</span>
        watch.listenerFn(newValue,oldValue,<span class="keyword">self</span>);
        watch.last=newValue;
    }
    })
}
</code></pre><p>测试：</p>
<pre><code>var scope=new Scope();
scope.firstName=<span class="string">'joe'</span>;
scope.counter=<span class="number">0</span>;
console.log(scope.counter);／／输出 <span class="number">0</span>
scope.<span class="variable">$watch</span>(
    <span class="keyword">function</span>(scope){return scope.firstName;},
    <span class="keyword">function</span>(newValue,oldValue,scope){scope.counter++}
    )
scope.<span class="variable">$digest</span>();
scope.firstName=<span class="string">'joe2'</span>; 
scope.<span class="variable">$digest</span>();
console.log(scope.counter)；／／输出<span class="number">2</span>
</code></pre><h2 id="版本3：bug_修复，对没有listenFn的支持，修复了$watch函数">版本3：bug 修复，对没有listenFn的支持，修复了$watch函数</h2><pre><code><span class="keyword">function</span> Scope() {
this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function(){} ／／新增一个判断，如果listener为undefined,返回一个fn对象
};
this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
var self = this;
    <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (newValue !== oldValue) {
        watch.listenerFn(newValue, oldValue, self);
        watch.last = newValue;
    }
});
};

var scope = new Scope();
scope.<span class="variable">$watch</span>(<span class="keyword">function</span>() {
console.log(<span class="string">'digest listener fired'</span>);//输出
});
</code></pre><h2 id="版本4：如果在另外一个listenerFn中修改了_scope中的值怎么办？">版本4：如果在另外一个listenerFn中修改了 scope中的值怎么办？</h2><p> 下面的例子：</p>
<pre><code><span class="keyword">function</span> Scope() {
      this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
      var watcher = {
        watchFn: watchFn,
        listenerFn: listenerFn || function() {}
      };
      this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
      var self = this;
      <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
        var newValue = watch.watchFn(self);
        var oldValue = watch.last;
            if (newValue !== oldValue) {
              watch.listenerFn(newValue, oldValue, self);
              watch.last = newValue;
        }
      });  
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
scope.firstName = <span class="string">'Joe'</span>;
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {return scope.counter;}
    ,
      <span class="keyword">function</span>(newValue, oldValue, scope) {
        scope.counterIsTwo = (newValue === <span class="number">2</span>);
      }
);

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {
    return scope.firstName;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

// 输出 <span class="number">1</span>
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">1</span>);

// 执行完 <span class="variable">$digest</span>()后 scope.counter 为<span class="number">2</span>但是，第一个 <span class="variable">$watch</span>函数并没有被通知到，listenerFn并没有被执行
scope.firstName = <span class="string">'Jane'</span>;
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>);
console.assert(scope.counterIsTwo); // 输出<span class="literal">false</span>

// 这时候再调用<span class="variable">$digest</span>()函数后，watch 函数被调用，输出 <span class="literal">true</span>
scope.<span class="variable">$digest</span>();
console.assert(scope.counterIsTwo); // <span class="literal">true</span>
</code></pre><p>这个例子中，第二个watch中的listenerFn 改变了counter的值，但是第一个watch没有被通知到，直到再次调用$digest()函数后才被执行。</p>
<h2 id="版本4:_修复在一个$watch中改变另外一个scope中的值，无法检测问题bug">版本4: 修复在一个$watch中改变另外一个scope中的值，无法检测问题bug</h2><p> 必须等所有的值都被校验结束，没有变化后才退出$deigest,把$digest函数重新命名为$digestOnce(),定义个变量dirty变量，如果dirty变量为true，证明还有数据发生了变化，执行$digest();</p>
<pre><code>     Scope.prototype.<span class="variable">$$digestOnce</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
      <span class="keyword">var</span> <span class="keyword">self</span>  = this;
      <span class="keyword">var</span> dirty;
      _.<span class="keyword">forEach</span>(this.<span class="variable">$$watchers</span>, <span class="function"><span class="keyword">function</span><span class="params">(watch)</span> </span>{
    <span class="keyword">var</span> newValue = watch.watchFn(<span class="keyword">self</span>);
    <span class="keyword">var</span> oldValue = watch.last;
    <span class="keyword">if</span> (newValue !== oldValue) {
       watch.listenerFn(newValue, oldValue, <span class="keyword">self</span>);
          dirty = <span class="keyword">true</span>;
          watch.last = newValue;
    }
  });
      <span class="keyword">return</span> dirty; <span class="comment">//增加标志位</span>
};

Scope.prototype.<span class="variable">$digest</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
      <span class="keyword">var</span> dirty; <span class="comment">// do while // 至少执行一次，所以只要有dirty 为true 都会检测一次，确保所有数据都是最新的</span>
      <span class="keyword">do</span> {
        dirty = this.<span class="variable">$$digestOnce</span>();
      } <span class="keyword">while</span> (dirty);
};
</code></pre><h2 id="版本5:_在一另外一个watch中改变另外一个scope中的值，会造成死循环。">版本5: 在一另外一个watch中改变另外一个scope中的值，会造成死循环。</h2><pre><code> <span class="keyword">function</span> Scope() {
      this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
   var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { }
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
      var self  = this;
      var dirty;
      <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (newValue !== oldValue) {
       watch.listenerFn(newValue, oldValue, self);
          dirty = true;
          watch.last = newValue;
    }
  });
      return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
      var dirty;
      do {
        dirty = this.$<span class="variable">$digestOnce</span>();
      } while (dirty);
};

var scope = new Scope();
scope.counter1 = <span class="number">0</span>;
scope.counter2 = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {
    return scope.counter1;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter2++;
      }
);

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {
    return scope.counter2;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter1++;
  }
);

// Uncomment this <span class="keyword">to</span> run the digest
// scope.<span class="variable">$digest</span>(); 这段代码会造成 游览器死循环，循环<span class="number">10</span>，<span class="number">0000</span>次后抛出异常。

console.log(scope.counter1);
</code></pre><h2 id="版本6:修复死循环问题">版本6:修复死循环问题</h2><p>增加一个标志位，当超过10次后推出循环。其余代码不变，如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { }
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (newValue !== oldValue) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = newValue;
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>测试：    </p>
<pre><code>var scope = new Scope();
scope.counter1 = <span class="number">0</span>;
scope.counter2 = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.counter1;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter2++;
  }
);

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.counter2;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter1++;
  }
);

scope.<span class="variable">$digest</span>();  //抛除异常后退出
</code></pre><h2 id="版本6:_改变比较方式">版本6: 改变比较方式</h2><p>现在所有的比较都用的绝对不等（!==）比较javascript中的基本数据类型，string, number还可以，要是比较数组这种引用类型的时候就，只要值想等就需要用equals（）了，改变$watch函数</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { },
    valueEq: !!valueEq //增加一个标志位置，如果valueEq为 undefined那么 valueEq为 false，默认的都是进行绝对比较。
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) { //只比较 数值
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue;
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>测试：</p>
<pre><code>var <span class="keyword">scope</span> = <span class="keyword">new</span> Scope();
<span class="keyword">scope</span>.counterByRef = <span class="number">0</span>;
<span class="keyword">scope</span>.counterByValue = <span class="number">0</span>;
<span class="keyword">scope</span>.value = [<span class="number">1</span>, <span class="number">2</span>, {three: [<span class="number">4</span>, <span class="number">5</span>]}];


<span class="keyword">scope</span>.$watch(
  <span class="built_in">function</span>(<span class="keyword">scope</span>) {
    <span class="keyword">return</span> <span class="keyword">scope</span>.value;
  },
  <span class="built_in">function</span>(newValue, oldValue, <span class="keyword">scope</span>) {
    <span class="keyword">scope</span>.counterByRef++;
  }
);
<span class="keyword">scope</span>.$watch(
  <span class="built_in">function</span>(<span class="keyword">scope</span>) {
    <span class="keyword">return</span> <span class="keyword">scope</span>.value;
  },
  <span class="built_in">function</span>(newValue, oldValue, <span class="keyword">scope</span>) {
    <span class="keyword">scope</span>.counterByValue++;
  },
  <span class="literal">true</span>
);

<span class="comment">//输出true</span>
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">1</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">1</span>);

<span class="comment">// 输出true</span>
<span class="keyword">scope</span>.value[<span class="number">2</span>].three.push(<span class="number">6</span>);
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">1</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">2</span>);

<span class="comment">// 引用类型 输出 true </span>
<span class="keyword">scope</span>.value = {aNew: <span class="string">"value"</span>};
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">2</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">3</span>);

<span class="keyword">delete</span> <span class="keyword">scope</span>.value;
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">3</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">4</span>);
</code></pre><h2 id="版本7:_处理错误的比较值_NaN（not_a_number）">版本7: 处理错误的比较值 NaN（not a number）</h2><p>修复比较函数，其余代码未做任何更改：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue)); //增加对NaN的判断
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
scope.number = <span class="number">0</span>;
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.number;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);


scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">1</span>); ／／ <span class="literal">true</span>

scope.number = parseInt(<span class="string">'wat'</span>, <span class="number">10</span>); // NaN 
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>);//输出 <span class="literal">true</span>
</code></pre><h2 id="版本8:把变量加入scope的执行上下文环境中实现_$eval">版本8:把变量加入scope的执行上下文环境中实现 $eval</h2><pre><code>Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span>(<span class="params">expr, locals</span>) </span>{
  <span class="keyword">return</span> expr(<span class="keyword">this</span>, locals); <span class="comment">//回调，的时候把关键字this作为参数传递给函数。</span>
};
</code></pre><p>完整的代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

var scope = new Scope();
scope.number = <span class="number">1</span>;

scope.<span class="variable">$eval</span>(<span class="keyword">function</span>(theScope) { ／／theScope  变量就是 this，所以输出<span class="number">1</span>
  console.log(<span class="string">'Number during $eval:'</span>, theScope.number);
});
</code></pre><h2 id="版本9:$apply_-_把外部的数据，加入scope的执行幻境。">版本9:$apply - 把外部的数据，加入scope的执行幻境。</h2><p>其实就是在$apply函数中调用 $eval()函数</p>
<pre><code>Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
      try {
        return this.<span class="variable">$eval</span>(expr);
      } finally {
        this.<span class="variable">$digest</span>();  ／／即使发生异常后依然执行，脏数据监测
      }
    };
</code></pre><p>完整代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$digest</span>();
  }
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.aValue;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

scope.<span class="variable">$apply</span>(<span class="keyword">function</span>(scope) {
  scope.aValue = <span class="string">'Hello from "outside"'</span>;
});
console.assert(scope.counter === <span class="number">1</span>); //<span class="literal">true</span>
</code></pre><h2 id="版本10:延迟执行函数实现。">版本10:延迟执行函数实现。</h2><p>在Javascript中要是用到延迟函数可以使用setTimeOut();我们要在$digest()后执行一个函数，这时我们打算自己实现一个队列，来存放要执行的函数，当满足条件后执行队列中的这个函数$evalAsync（），当$digest()函数执行后条件成立。回调asyncQueue 数组中的函数，函数的名字，仅仅是一个变量而已。</p>
<p>首先创建一个队列存放函数：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];／／队列存放 函数
}
</code></pre><p>自己可以使用firebug跟一下这个函数，当$digest()，当条件满足时执行队列中的函数，这就实现了延迟，在$digest()后执行就是延迟，在$digest()执行前就是提前执行：</p>
<pre><code>Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {//条件
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);／／回调函数
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>完整代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {//<span class="variable">$digest</span>()执行前while的条件为false，
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  this.$<span class="variable">$asyncQueue</span>.push({scope: this, expression: expr});
};
</code></pre><p>测试：提示（firebug 一步一的看一遍就明白了）</p>
<pre><code>var <span class="keyword">scope</span> = <span class="keyword">new</span> Scope();
<span class="keyword">scope</span>.asyncEvaled = <span class="literal">false</span>;

<span class="keyword">scope</span>.$watch(
  <span class="built_in">function</span>(<span class="keyword">scope</span>) {
    <span class="keyword">return</span> <span class="keyword">scope</span>.aValue;
  },
  <span class="built_in">function</span>(newValue, oldValue, <span class="keyword">scope</span>) {
    <span class="keyword">scope</span>.counter++;
    <span class="keyword">scope</span>.$evalAsync(<span class="built_in">function</span>(<span class="keyword">scope</span>) { <span class="comment">//  回调函数执行这段代码</span>
      <span class="keyword">scope</span>.asyncEvaled = <span class="literal">true</span>;
    });
    console.log(<span class="string">"Evaled inside listener: "</span>+<span class="keyword">scope</span>.asyncEvaled);／／ 这段代码 输出<span class="string">"Evaled inside listener: false"</span> ；因为这段代码执行的时候，回调函数并没有执行,使用队列和回调函数实现延迟。可以使用firebug 进行观察。
  }
);

<span class="keyword">scope</span>.aValue = <span class="string">"test"</span>;
<span class="keyword">scope</span>.$digest();
console.log(<span class="string">"Evaled after digest: "</span>+<span class="keyword">scope</span>.asyncEvaled);  ／／输出 <span class="literal">true</span>
</code></pre><h2 id="版本11:修复版本10中的一个bug，当两个$digest同时执行时会对公共变量this-$$asyncQueue_=_[]造成影响，只要$asyncQueue[]长度不为0，第二个$digest()遇到while循环的时候就会执行。所以添加一个标志位this-$$phase_当它不为null的时候就抛出一个异常，证明有函数正在执行，确保时单线程的。">版本11:修复版本10中的一个bug，当两个$digest同时执行时会对公共变量this.$$asyncQueue = []造成影响，只要$asyncQueue[]长度不为0，第二个$digest()遇到while循环的时候就会执行。所以添加一个标志位this.$$phase 当它不为null的时候就抛出一个异常，证明有函数正在执行，确保时单线程的。</h2><pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};
</code></pre><p>测试：</p>
<pre><code>var <span class="keyword">scope</span> = <span class="keyword">new</span> Scope();
<span class="keyword">scope</span>.asyncEvaled = <span class="literal">false</span>;

<span class="keyword">scope</span>.$evalAsync(<span class="built_in">function</span>(<span class="keyword">scope</span>) {
  <span class="keyword">scope</span>.asyncEvaled = <span class="literal">true</span>;
});

setTimeout(<span class="built_in">function</span>() {
  console.log(<span class="string">"Evaled after a while: "</span>+<span class="keyword">scope</span>.asyncEvaled);
}, <span class="number">100</span>); <span class="comment">//     延迟执行，确保digest函数可以运行</span>
</code></pre><p>版本12：在$deigest后执行的函数 - $$postDigest,这个函数有两个$$符号，证明我们的应用时不能调用这个函数的，这个函数会在$digest满足while条件后立即执行。</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$postDigestQueue</span> = []; // 新增的延迟函数
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    this.$<span class="variable">$postDigestQueue</span>.shift()();
  }
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};

Scope.prototype.$<span class="variable">$postDigest</span> = <span class="keyword">function</span>(fn) {
  this.$<span class="variable">$postDigestQueue</span>.push(fn);
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
var postDigestInvoked = <span class="literal">false</span>;

scope.$<span class="variable">$postDigest</span>(<span class="keyword">function</span>() { // 往数组里面存值
  postDigestInvoked = true;
});

console.assert(!postDigestInvoked);

scope.<span class="variable">$digest</span>();
console.assert(postDigestInvoked);
</code></pre><h2 id="版本12:异常处理添加_try_catch_使函数变的跟健壮，处理_$evalAsync_function,_或者_$$postDigest带来的异常">版本12:异常处理添加 try  catch 使函数变的跟健壮，处理 $evalAsync function, 或者  $$postDigest带来的异常</h2><pre><code>Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      try {&lt;!--包裹异常--&gt;
        var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
        this.<span class="variable">$eval</span>(asyncTask.expression);
      } catch (e) {
        (console.error || console.log)(e);
      }
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    try {&lt;!--包裹异常--&gt;
      this.$<span class="variable">$postDigestQueue</span>.shift()();
    } catch (e) {
      (console.error || console.log)(e);
    }
  }
};
</code></pre><p>完整的测试代码如下，会制造异常，用来测试：</p>
<pre><code>    <span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$postDigestQueue</span> = [];
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    try {
      var newValue = watch.watchFn(self);
      var oldValue = watch.last;
      if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
        watch.listenerFn(newValue, oldValue, self);
        dirty = true;
        watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
      }
    } catch (e) {
      (console.error || console.log)(e);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      try {
        var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
        this.<span class="variable">$eval</span>(asyncTask.expression);
      } catch (e) {
        (console.error || console.log)(e);
      }
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    try {
      this.$<span class="variable">$postDigestQueue</span>.shift()();
    } catch (e) {
      (console.error || console.log)(e);
    }
  }
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};

Scope.prototype.$<span class="variable">$postDigest</span> = <span class="keyword">function</span>(fn) {
  this.$<span class="variable">$postDigestQueue</span>.push(fn);
};
</code></pre><p>测试：<!--抛出异常后函数正常执行--></p>
<pre><code>var scope = new Scope();
scope.aValue = <span class="string">"abc"</span>;
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(<span class="keyword">function</span>() {
  throw <span class="string">"Watch fail"</span>;
});
scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    scope.<span class="variable">$evalAsync</span>(function(scope) {
      throw <span class="string">"async fail"</span>;
    });
    return scope.aValue;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

scope.<span class="variable">$digest</span>(); 
console.assert(scope.counter === <span class="number">1</span>);
</code></pre><h2 id="版本13:移除watch函数中的对象，即销毁对象，用到了闭包，改造$watch函数，如果只是初始化定义$watch函数，watch函数中的return函数时不会执行的。">版本13:移除watch函数中的对象，即销毁对象，用到了闭包，改造$watch函数，如果只是初始化定义$watch函数，watch函数中的return函数时不会执行的。</h2><pre><code>Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var self = this;
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn,
    valueEq: !!valueEq
  };
  self.$<span class="variable">$watchers</span>.push(watcher);
  return function() {
    var index = self.$<span class="variable">$watchers</span>.indexOf(watcher);
    if (index &gt;= <span class="number">0</span>) {
      self.$<span class="variable">$watchers</span>.splice(index, <span class="number">1</span>);
    }
  };
};
</code></pre><p>终极代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$postDigestQueue</span> = [];
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var self = this;
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { },
    valueEq: !!valueEq
  };
  self.$<span class="variable">$watchers</span>.push(watcher);
  return function() {
    var index = self.$<span class="variable">$watchers</span>.indexOf(watcher);
    if (index &gt;= <span class="number">0</span>) {
      self.$<span class="variable">$watchers</span>.splice(index, <span class="number">1</span>);
    }
  };
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    try {
      var newValue = watch.watchFn(self);
      var oldValue = watch.last;
      if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
        watch.listenerFn(newValue, oldValue, self);
        dirty = true;
        watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
      }
    } catch (e) {
      (console.error || console.log)(e);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      try {
        var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
        this.<span class="variable">$eval</span>(asyncTask.expression);
      } catch (e) {
        (console.error || console.log)(e);
      }
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    try {
      this.$<span class="variable">$postDigestQueue</span>.shift()();
    } catch (e) {
      (console.error || console.log)(e);
    }
  }
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};

Scope.prototype.$<span class="variable">$postDigest</span> = <span class="keyword">function</span>(fn) {
  this.$<span class="variable">$postDigestQueue</span>.push(fn);
};


var scope = new Scope();
scope.aValue = <span class="string">"abc"</span>;
scope.counter = <span class="number">0</span>;
&lt;!--初始化watch函数--&gt;
var removeWatch = scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.aValue;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">1</span>);

scope.aValue = <span class="string">'def'</span>;
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>);
&lt;!--调用watch函数，移除上一个元素--&gt;
removeWatch();
scope.aValue = <span class="string">'ghi'</span>;
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>); // <span class="literal">true</span>,不是<span class="number">3</span>
</code></pre><p>要检验一个知识点，所学是否透彻，最直接的方式就时造轮子，Angular的核心代码有1万4千多行，看起来还是挺费劲的。博客里的这篇文章参考了：<a href="http://teropa.info/build-your-own-angular" target="_blank" rel="external">Build Your Own AngularJS</a>，感谢作者的分享，为止见过最好的一本讲解 Angular原理的一本书，Angular中虽然有很多坑（自己学艺不精）但是依然是个非常优秀的框架，在平时的项目中一步步填坑，验证一句老话，实践时最好的老师。</p>

      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2015/11/20/Angaular-digest/" data-id="cijsmg7t60000xfkqwavct0mn" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/AngularJS/">AngularJS</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Angular-Js-Controller" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/11/08/Angular-Js-Controller/" class="article-date">
  <time datetime="2015-11-08T08:42:34.000Z" itemprop="datePublished">2015-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/11/08/Angular-Js-Controller/">Angular js 两个Controller之间通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么才是_angular_controller之间的正确通信姿势">什么才是 angular controller之间的正确通信姿势</h2><p>当一个controller中的数据发生变化的时候另外一个controller中的元素也要做相应的变化。项目中遇到的一个需求就是，当用户上传头完头像的时候，页面中其它用到头像的dom数据也要发生变化。</p>
<p>stackoverflow上面对着问题也有探讨: <a href="http://stackoverflow.com/questions/11252780/whats-the-correct-way-to-communicate-between-controllers-in-angularjs" target="_blank" rel="external">here</a>.</p>
<p><strong>总结</strong>  </p>
<p>1 不够优雅的方式：把共享的变量放在$rootScope，只要$rootScope中的共享变量改变了，所有页面中的数据跟着变化，rootscope是各个controller中scope的桥梁。用rootscope定义的值，可以在各个controller中使用。<strong>不推荐造成数据污染</strong>  </p>
<p>2 使用angular 提供的事件通知 $broadcast和$emit，两者的区别(<a href="http://stackoverflow.com/questions/26752030/rootscope-broadcast-vs-scope-emit" target="_blank" rel="external">$emit VS $broadcast</a>)<br>$broadcast事件传播的方向是<strong>向下</strong>的，而<strong>$emit</strong>是向上的。这两种传播方式在复杂的页面布局中都会影响性能。<strong>不推荐</strong>  </p>
<p>3 <strong>优雅方式</strong>是使用 <strong>service</strong>  </p>
<p>在service中使用<strong>回调函数</strong>，把service注入到 controller里接下来看代码：</p>
<pre><code><span class="built_in">module</span>.factory(<span class="string">"eventBus"</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>{
<span class="keyword">var</span> obj = {};
obj.handlers = {};
obj.registerEvent = <span class="function"><span class="keyword">function</span> (<span class="params">eventName,handler</span>)</span>{
    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.handlers[eventName] == <span class="string">'undefined'</span>){
    <span class="keyword">this</span>.handlers[eventName] = [];  
}       
<span class="keyword">this</span>.handlers[eventName].push(handler);
}
obj.fireEvent = <span class="function"><span class="keyword">function</span> (<span class="params">eventName,objData</span>)</span>{
   <span class="keyword">if</span>(<span class="keyword">this</span>.handlers[eventName]){
       <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.handlers[eventName].length;i++){
            <span class="keyword">this</span>.handlers[eventName][i](objData);
       }

   }
}
<span class="keyword">return</span> obj;
})


<span class="comment">//Usage:</span>

<span class="comment">//回调的controller</span>
eventBus.registerEvent(<span class="string">'fakeEvent'</span>,handler)
<span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">data</span>)</span>{
  alert(data);
}

<span class="comment">//事件触发的controller</span>
eventBus.fireEvent(<span class="string">'fakeEvent'</span>,<span class="string">'fakeData'</span>);
</code></pre><p>使用回调函数的这种方式无疑是<strong>提高了灵活性，提高了代码的性能，所以我</strong>推荐**使用这种方式。</p>
<p>service无疑是给controller之间提供了桥梁，让两个controller共享一块内存，所以两个controller虽然使用了不同的作用域，但是只要注入了service，service中的方法依然可以被两个controller共享。</p>

      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2015/11/08/Angular-Js-Controller/" data-id="cijsmg7uh0009xfkqby138ocr" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Angular/">Angular</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Mac-Install-Hexo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/11/07/Mac-Install-Hexo/" class="article-date">
  <time datetime="2015-11-07T15:29:32.000Z" itemprop="datePublished">2015-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/11/07/Mac-Install-Hexo/">Mac下搭建Hexo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="环境安装">环境安装</h1><p><strong>hexo</strong>的版本信息：<strong>3.1.1</strong> 网上大多数的参考资料都是2.x版本的，对于新手来说还是有很多不太一样。</p>
<p><strong>brew</strong> 安装Mac 软件管理工具brew，命令行方式进行安装：  </p>
<pre><code>ruby <span class="operator">-e</span> <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span>      
</code></pre><p>直接复制到终端，brew 就可以下载下来了参考:<a href="http://brew.sh" target="_blank" rel="external">http://brew.sh</a></p>
<p><strong>安装node.js</strong>  </p>
<pre><code>brew install <span class="keyword">node</span><span class="identifier"></span><span class="title"></span>
</code></pre><p>使用 node －v 看看是否成功，如果失败继续执行 上面命令  </p>
<p> <strong>安装Hexo</strong><br> 版本3使用如下命令：  </p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-cli -<span class="keyword">g</span>
//安装一个 <span class="keyword">server</span> 模块
npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save  </span></span>
</code></pre><p>次过程可能比较缓慢，安装完成后建立一个你的blog 目录，比如在/Users/xx/blog      执行</p>
<pre><code><span class="built_in">cd</span>  blog
hexo init  <span class="comment">// 下面这两个步骤不可有误，顺序不能反</span>
npm install
</code></pre><p> Hexo就安装完成了！</p>
<p> <strong>验证Hexo</strong>        </p>
<p> 创建一篇文章  </p>
<pre><code>hexo <span class="keyword">new</span> <span class="string">"test"</span>
hexo generate
hexo <span class="keyword">server</span>  
</code></pre><p>  此时你可以在本地游览器中预览一下生成的静态网页,Ctrl+C关闭。</p>
<p>  <strong>每次更新博客</strong></p>
<pre><code>hexo <span class="keyword">clear</span>
hexo <span class="keyword">generate</span>
hexo server  
</code></pre><p> 可以在浏览器中预览。此时没有配置任何的_config.yml</p>
<p> <strong>整合Githbu</strong></p>
<p> 此时还需要安装git的一个模块  </p>
<pre><code>npm <span class="operator"><span class="keyword">install</span> hexo-deployer-git <span class="comment">--save ／／为了部署</span></span>
</code></pre><p> 首先你和Github之间得有一条连接，必须使用ssh连接，使用ssh连接时候我们得把公钥添加到Github上。   </p>
<p><strong>创建GitHub公钥</strong>    </p>
<p>使用的是如下命令</p>
<pre><code>ssh-keygen -t rsa -C <span class="string">"your_email@example.com"</span> <span class="comment">//这里的邮箱是你在注册git的时候填写的验证邮箱。</span>
</code></pre><p>默认的公钥生成位置为：~/.ssh/id_rsa.pub把这个文件打开，在GitHub上打开setting-&gt; SSH Keys,添加一个key，title 随便起一个名字，把key复制进去。使用了ssh连接后你每次提交都不需要密码，查看你用什么方式提交的。  </p>
<pre><code>git remote -v <span class="comment">//我的提交方式如下</span>
origin    git@github<span class="class">.com</span>:junsoft/blog<span class="class">.git</span> (fetch) ／／origin后面的信息为你git上的提交信息
origin    git@github<span class="class">.com</span>:junsoft/blog<span class="class">.git</span> (push)
</code></pre><p>如果你的是https提交做如下修改：</p>
<pre><code>git remote origin <span class="operator"><span class="keyword">set</span>-<span class="keyword">url</span> &lt;<span class="keyword">URL</span>&gt; 
把&lt;<span class="keyword">URL</span>&gt;替换成新的ssh的 <span class="keyword">url</span>地址    </span>
</code></pre><p><strong>Github上创建一个Repostitories</strong>  </p>
<p> Repostitory name就是你以后博客的发布路径。</p>
<p> <strong>做一个最简单的配置hexo</strong></p>
<p> 我们只需要打开  vi _config.yml 在最后添加如下信息，<strong>版本3的type类型必须为git，分支必须为gh-pages</strong>  因为github规定，在项目类型的仓库中，只有该分支中的页面，才会生成网页文件</p>
<pre><code><span class="comment"># URL</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
root: /blog      //是你要发布的路径，就是仓库的名称
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>
deploy:
 type: git
 repository: git<span class="comment">@github.com:junsoft/blog.git</span>
 branch: gh-pages
</code></pre><p> 此时执行如下命令，就可以访问你博客了：<a href="http://XXX.github.io/blog/" target="_blank" rel="external">http://XXX.github.io/blog/</a>  ／／xxx为你Github的名字。</p>
<pre><code>hexo <span class="keyword">clear</span>
hexo <span class="keyword">generate</span>
hexo deploy
</code></pre><p> 本篇教程之探讨如何最小化的搭建一个Hello word Hexo,到此搭建结束。</p>

      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2015/11/07/Mac-Install-Hexo/" data-id="cijsmg7ue0006xfkqq3arqt1x" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Hexo博客搭建/">Hexo博客搭建</a></li></ul>

    </footer>
  </div>
  
</article>




  
  

{% block title %} {{ theme.keywords }} - {{ config.title }} - {{ theme.description }} {% endblock %}
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近博客</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/01/24/js/">javaScript 继承</a>
          </li>
        
          <li>
            <a href="/blog/2015/11/20/Angaular-digest/">实现Angualrjs脏数据监测</a>
          </li>
        
          <li>
            <a href="/blog/2015/11/08/Angular-Js-Controller/">Angular js 两个Controller之间通信</a>
          </li>
        
          <li>
            <a href="/blog/2015/11/07/Mac-Install-Hexo/">Mac下搭建Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">十一月 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Angular/" style="font-size: 10px;">Angular</a> <a href="/blog/tags/AngularJS/" style="font-size: 10px;">AngularJS</a> <a href="/blog/tags/Hexo博客搭建/" style="font-size: 10px;">Hexo博客搭建</a> <a href="/blog/tags/javaScript-继承/" style="font-size: 10px;">javaScript 继承</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 苍晨<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
       

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>