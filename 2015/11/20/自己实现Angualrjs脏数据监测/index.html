<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>实现Angualrjs脏数据监测 | 苍晨的技术博文</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Angular的不同点谷歌的Angular JS是一个非常强大优秀的前段框架，它颠覆了我们以往对前段的认识，以前说到前端首先想到jQuery去操作Dom元素，但在Angular中切都是数据为王。
angular中是如何实现脏数据监测的？我们需要用到的类库：lodash.js比较好用的js工具库，用它的目的仅仅是为了操作数组，Angular中并没有用到。lodash 下载  
loads的一些例子:">
<meta property="og:type" content="article">
<meta property="og:title" content="实现Angualrjs脏数据监测">
<meta property="og:url" content="http://yoursite.com/2015/11/20/自己实现Angualrjs脏数据监测/index.html">
<meta property="og:site_name" content="苍晨的技术博文">
<meta property="og:description" content="Angular的不同点谷歌的Angular JS是一个非常强大优秀的前段框架，它颠覆了我们以往对前段的认识，以前说到前端首先想到jQuery去操作Dom元素，但在Angular中切都是数据为王。
angular中是如何实现脏数据监测的？我们需要用到的类库：lodash.js比较好用的js工具库，用它的目的仅仅是为了操作数组，Angular中并没有用到。lodash 下载  
loads的一些例子:">
<meta property="og:updated_time" content="2015-11-24T13:14:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现Angualrjs脏数据监测">
<meta name="twitter:description" content="Angular的不同点谷歌的Angular JS是一个非常强大优秀的前段框架，它颠覆了我们以往对前段的认识，以前说到前端首先想到jQuery去操作Dom元素，但在Angular中切都是数据为王。
angular中是如何实现脏数据监测的？我们需要用到的类库：lodash.js比较好用的js工具库，用它的目的仅仅是为了操作数组，Angular中并没有用到。lodash 下载  
loads的一些例子:">
  
    <link rel="alternative" href="/atom.xml" title="苍晨的技术博文" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">苍晨的技术博文</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我走过脚印也曾留下，苍穹之下却渺如尘沙</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-自己实现Angualrjs脏数据监测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2015/11/20/自己实现Angualrjs脏数据监测/" class="article-date">
  <time datetime="2015-11-20T12:33:15.000Z" itemprop="datePublished">2015-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      实现Angualrjs脏数据监测
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Angular的不同点">Angular的不同点</h1><p>谷歌的Angular JS是一个非常强大优秀的前段框架，它颠覆了我们以往对前段的认识，以前说到前端首先想到jQuery去操作Dom元素，但在Angular中切都是数据为王。</p>
<h2 id="angular中是如何实现脏数据监测的？">angular中是如何实现脏数据监测的？</h2><p>我们需要用到的类库：lodash.js比较好用的js工具库，用它的目的仅仅是为了操作数组，Angular中并没有用到。<a href="https://github.com/lodash/lodash" target="_blank" rel="external">lodash 下载</a>  </p>
<p>loads的一些例子:</p>
<pre><code>var a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
var b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];
var c= _.<span class="built_in">map</span>(a,function(i){  <span class="comment">// 迭代 map 中的每一元素，返回一个新的列表</span>
<span class="keyword">return</span> i*<span class="number">2</span>;
})

console.assert(a!==b);
console.assert(_.isEqual(a,b));
console.assert(_.isEqual([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>],c));
</code></pre><h1 id="循序渐进的造轮子">循序渐进的造轮子</h1><h2 id="版本1：创建一个全局的Scope作用域">版本1：创建一个全局的Scope作用域</h2><pre><code>/＊＊细节按照javascript的惯例 构造函数始终都应该方法名大写,而非构造函数则应该小写主要是为了区分ECMASScript中的其它函数

/＊＊什么才是构造函数？
    没有显示的创建对象
    直接将属性和方法赋给<span class="keyword">this</span> 对象
    没有<span class="keyword">return</span> 语句
    要创建构造函数的实例 必须使用 <span class="keyword">new</span> 操作符号
＊＊/


<span class="comment">//创建 Angular中的Scope</span>

<span class="function"><span class="keyword">function</span> <span class="title">Scope</span><span class="params">()</span></span>{
}
<span class="keyword">var</span> scope=<span class="keyword">new</span> Scope();
scope.firstName=<span class="string">'jun'</span>
scope.lastName=<span class="string">'tom'</span>
</code></pre><p>为了监控Scope中的数据变化,我们需要给Scope中存在一个数组来保存scope中的元素</p>
<pre><code><span class="keyword">function</span> Scope(){
this.$<span class="variable">$watchers</span>=[]; //保存数据, 在Angualr中所有$$开头的变量都是私有
}
</code></pre><p>为了监控 $$watchers数组中的数据变化需要创建一个watch函数，使用原型构造链的方式创建</p>
<pre><code>Scope.prototype.<span class="variable">$watch</span>=<span class="keyword">function</span>(watchFn,listenerFn){
var watcher={
    watchFn:watchFn,
    listenerFn:listenerFn
};
this.$<span class="variable">$watchers</span>.push(watcher); //把传递过来的参数，封装为一个对象，入栈
}
</code></pre><p>创建一个$digest函数用于检测scope中的数据有没有变化，使用digest函数回调watch中的listenFn函数。</p>
<pre><code>    Scope.prototype.<span class="variable">$digest</span>=<span class="keyword">function</span>(){
    <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>,function(watch){ //lodash.js工具类中提供的遍历数组方法。
    watch.listenerFn();//回调
    })
}
</code></pre><p>测试：</p>
<pre><code>var scope=new Scope();
scope.<span class="variable">$watch</span>(
    <span class="keyword">function</span>(){console.log(<span class="string">'aa'</span>)},
    <span class="keyword">function</span>(){console.log(<span class="string">'listener'</span>)}
    )
scope.<span class="variable">$digest</span>();

输出：listener
</code></pre><h2 id="版本2：脏数据监测">版本2：脏数据监测</h2><pre><code><span class="keyword">function</span> Scope(){
this.$<span class="variable">$watchers</span>=[]; 
}

Scope.prototype.<span class="variable">$watch</span>=<span class="keyword">function</span>(watchFn,listenerFn){
var watcher={
    watchFn:watchFn,
    listenerFn:listenerFn
};
this.$<span class="variable">$watchers</span>.push(watcher);
}
</code></pre><p>上面这和版本一摸一样，变化的是$digest函数，添加一个比较功能：</p>
<pre><code>Scope.prototype.<span class="variable">$digest</span>=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
    <span class="keyword">var</span> <span class="keyword">self</span>=this;
    _.<span class="keyword">forEach</span>(this.<span class="variable">$$watchers</span>,<span class="function"><span class="keyword">function</span><span class="params">(watch)</span></span>{
    <span class="keyword">var</span> newValue=watch.watchFn(<span class="keyword">self</span>); <span class="comment">//给把scope当作变量传递给watchFn,,获得这个scope的新        的value</span>
    <span class="keyword">var</span> oldValue=watch.last; <span class="comment">// 定义一个last变量 第一次值是undefined</span>
    <span class="keyword">if</span>(newValue !==oldValue){ <span class="comment">//新增的比较功能 ！＝＝为绝对相等</span>
        watch.listenerFn(newValue,oldValue,<span class="keyword">self</span>);
        watch.last=newValue;
    }
    })
}
</code></pre><p>测试：</p>
<pre><code>var scope=new Scope();
scope.firstName=<span class="string">'joe'</span>;
scope.counter=<span class="number">0</span>;
console.log(scope.counter);／／输出 <span class="number">0</span>
scope.<span class="variable">$watch</span>(
    <span class="keyword">function</span>(scope){return scope.firstName;},
    <span class="keyword">function</span>(newValue,oldValue,scope){scope.counter++}
    )
scope.<span class="variable">$digest</span>();
scope.firstName=<span class="string">'joe2'</span>; 
scope.<span class="variable">$digest</span>();
console.log(scope.counter)；／／输出<span class="number">2</span>
</code></pre><h2 id="版本3：bug_修复，对没有listenFn的支持，修复了$watch函数">版本3：bug 修复，对没有listenFn的支持，修复了$watch函数</h2><pre><code><span class="keyword">function</span> Scope() {
this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function(){} ／／新增一个判断，如果listener为undefined,返回一个fn对象
};
this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
var self = this;
    <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (newValue !== oldValue) {
        watch.listenerFn(newValue, oldValue, self);
        watch.last = newValue;
    }
});
};

var scope = new Scope();
scope.<span class="variable">$watch</span>(<span class="keyword">function</span>() {
console.log(<span class="string">'digest listener fired'</span>);//输出
});
</code></pre><h2 id="版本4：如果在另外一个listenerFn中修改了_scope中的值怎么办？">版本4：如果在另外一个listenerFn中修改了 scope中的值怎么办？</h2><p> 下面的例子：</p>
<pre><code><span class="keyword">function</span> Scope() {
      this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
      var watcher = {
        watchFn: watchFn,
        listenerFn: listenerFn || function() {}
      };
      this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
      var self = this;
      <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
        var newValue = watch.watchFn(self);
        var oldValue = watch.last;
            if (newValue !== oldValue) {
              watch.listenerFn(newValue, oldValue, self);
              watch.last = newValue;
        }
      });  
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
scope.firstName = <span class="string">'Joe'</span>;
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {return scope.counter;}
    ,
      <span class="keyword">function</span>(newValue, oldValue, scope) {
        scope.counterIsTwo = (newValue === <span class="number">2</span>);
      }
);

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {
    return scope.firstName;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

// 输出 <span class="number">1</span>
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">1</span>);

// 执行完 <span class="variable">$digest</span>()后 scope.counter 为<span class="number">2</span>但是，第一个 <span class="variable">$watch</span>函数并没有被通知到，listenerFn并没有被执行
scope.firstName = <span class="string">'Jane'</span>;
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>);
console.assert(scope.counterIsTwo); // 输出<span class="literal">false</span>

// 这时候再调用<span class="variable">$digest</span>()函数后，watch 函数被调用，输出 <span class="literal">true</span>
scope.<span class="variable">$digest</span>();
console.assert(scope.counterIsTwo); // <span class="literal">true</span>
</code></pre><p>这个例子中，第二个watch中的listenerFn 改变了counter的值，但是第一个watch没有被通知到，直到再次调用$digest()函数后才被执行。</p>
<h2 id="版本4:_修复在一个$watch中改变另外一个scope中的值，无法检测问题bug">版本4: 修复在一个$watch中改变另外一个scope中的值，无法检测问题bug</h2><p> 必须等所有的值都被校验结束，没有变化后才退出$deigest,把$digest函数重新命名为$digestOnce(),定义个变量dirty变量，如果dirty变量为true，证明还有数据发生了变化，执行$digest();</p>
<pre><code>     Scope.prototype.<span class="variable">$$digestOnce</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
      <span class="keyword">var</span> <span class="keyword">self</span>  = this;
      <span class="keyword">var</span> dirty;
      _.<span class="keyword">forEach</span>(this.<span class="variable">$$watchers</span>, <span class="function"><span class="keyword">function</span><span class="params">(watch)</span> </span>{
    <span class="keyword">var</span> newValue = watch.watchFn(<span class="keyword">self</span>);
    <span class="keyword">var</span> oldValue = watch.last;
    <span class="keyword">if</span> (newValue !== oldValue) {
       watch.listenerFn(newValue, oldValue, <span class="keyword">self</span>);
          dirty = <span class="keyword">true</span>;
          watch.last = newValue;
    }
  });
      <span class="keyword">return</span> dirty; <span class="comment">//增加标志位</span>
};

Scope.prototype.<span class="variable">$digest</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
      <span class="keyword">var</span> dirty; <span class="comment">// do while // 至少执行一次，所以只要有dirty 为true 都会检测一次，确保所有数据都是最新的</span>
      <span class="keyword">do</span> {
        dirty = this.<span class="variable">$$digestOnce</span>();
      } <span class="keyword">while</span> (dirty);
};
</code></pre><h2 id="版本5:_在一另外一个watch中改变另外一个scope中的值，会造成死循环。">版本5: 在一另外一个watch中改变另外一个scope中的值，会造成死循环。</h2><pre><code> <span class="keyword">function</span> Scope() {
      this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
   var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { }
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
      var self  = this;
      var dirty;
      <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (newValue !== oldValue) {
       watch.listenerFn(newValue, oldValue, self);
          dirty = true;
          watch.last = newValue;
    }
  });
      return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
      var dirty;
      do {
        dirty = this.$<span class="variable">$digestOnce</span>();
      } while (dirty);
};

var scope = new Scope();
scope.counter1 = <span class="number">0</span>;
scope.counter2 = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {
    return scope.counter1;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter2++;
      }
);

scope.<span class="variable">$watch</span>(
      <span class="keyword">function</span>(scope) {
    return scope.counter2;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter1++;
  }
);

// Uncomment this <span class="keyword">to</span> run the digest
// scope.<span class="variable">$digest</span>(); 这段代码会造成 游览器死循环，循环<span class="number">10</span>，<span class="number">0000</span>次后抛出异常。

console.log(scope.counter1);
</code></pre><h2 id="版本6:修复死循环问题">版本6:修复死循环问题</h2><p>增加一个标志位，当超过10次后推出循环。其余代码不变，如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { }
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (newValue !== oldValue) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = newValue;
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>测试：    </p>
<pre><code>var scope = new Scope();
scope.counter1 = <span class="number">0</span>;
scope.counter2 = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.counter1;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter2++;
  }
);

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.counter2;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter1++;
  }
);

scope.<span class="variable">$digest</span>();  //抛除异常后退出
</code></pre><h2 id="版本6:_改变比较方式">版本6: 改变比较方式</h2><p>现在所有的比较都用的绝对不等（!==）比较javascript中的基本数据类型，string, number还可以，要是比较数组这种引用类型的时候就，只要值想等就需要用equals（）了，改变$watch函数</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { },
    valueEq: !!valueEq //增加一个标志位置，如果valueEq为 undefined那么 valueEq为 false，默认的都是进行绝对比较。
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) { //只比较 数值
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue;
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>测试：</p>
<pre><code>var <span class="keyword">scope</span> = <span class="keyword">new</span> Scope();
<span class="keyword">scope</span>.counterByRef = <span class="number">0</span>;
<span class="keyword">scope</span>.counterByValue = <span class="number">0</span>;
<span class="keyword">scope</span>.value = [<span class="number">1</span>, <span class="number">2</span>, {three: [<span class="number">4</span>, <span class="number">5</span>]}];


<span class="keyword">scope</span>.$watch(
  <span class="built_in">function</span>(<span class="keyword">scope</span>) {
    <span class="keyword">return</span> <span class="keyword">scope</span>.value;
  },
  <span class="built_in">function</span>(newValue, oldValue, <span class="keyword">scope</span>) {
    <span class="keyword">scope</span>.counterByRef++;
  }
);
<span class="keyword">scope</span>.$watch(
  <span class="built_in">function</span>(<span class="keyword">scope</span>) {
    <span class="keyword">return</span> <span class="keyword">scope</span>.value;
  },
  <span class="built_in">function</span>(newValue, oldValue, <span class="keyword">scope</span>) {
    <span class="keyword">scope</span>.counterByValue++;
  },
  <span class="literal">true</span>
);

<span class="comment">//输出true</span>
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">1</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">1</span>);

<span class="comment">// 输出true</span>
<span class="keyword">scope</span>.value[<span class="number">2</span>].three.push(<span class="number">6</span>);
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">1</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">2</span>);

<span class="comment">// 引用类型 输出 true </span>
<span class="keyword">scope</span>.value = {aNew: <span class="string">"value"</span>};
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">2</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">3</span>);

<span class="keyword">delete</span> <span class="keyword">scope</span>.value;
<span class="keyword">scope</span>.$digest();
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByRef === <span class="number">3</span>);
console.<span class="keyword">assert</span>(<span class="keyword">scope</span>.counterByValue === <span class="number">4</span>);
</code></pre><h2 id="版本7:_处理错误的比较值_NaN（not_a_number）">版本7: 处理错误的比较值 NaN（not a number）</h2><p>修复比较函数，其余代码未做任何更改：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue)); //增加对NaN的判断
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
scope.number = <span class="number">0</span>;
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.number;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);


scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">1</span>); ／／ <span class="literal">true</span>

scope.number = parseInt(<span class="string">'wat'</span>, <span class="number">10</span>); // NaN 
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>);//输出 <span class="literal">true</span>
</code></pre><h2 id="版本8:把变量加入scope的执行上下文环境中实现_$eval">版本8:把变量加入scope的执行上下文环境中实现 $eval</h2><pre><code>Scope.prototype.$<span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span>(<span class="params">expr, locals</span>) </span>{
  <span class="keyword">return</span> expr(<span class="keyword">this</span>, locals); <span class="comment">//回调，的时候把关键字this作为参数传递给函数。</span>
};
</code></pre><p>完整的代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

var scope = new Scope();
scope.number = <span class="number">1</span>;

scope.<span class="variable">$eval</span>(<span class="keyword">function</span>(theScope) { ／／theScope  变量就是 this，所以输出<span class="number">1</span>
  console.log(<span class="string">'Number during $eval:'</span>, theScope.number);
});
</code></pre><h2 id="版本9:$apply_-_把外部的数据，加入scope的执行幻境。">版本9:$apply - 把外部的数据，加入scope的执行幻境。</h2><p>其实就是在$apply函数中调用 $eval()函数</p>
<pre><code>Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
      try {
        return this.<span class="variable">$eval</span>(expr);
      } finally {
        this.<span class="variable">$digest</span>();  ／／即使发生异常后依然执行，脏数据监测
      }
    };
</code></pre><p>完整代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>(){
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$digest</span>();
  }
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.aValue;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

scope.<span class="variable">$apply</span>(<span class="keyword">function</span>(scope) {
  scope.aValue = <span class="string">'Hello from "outside"'</span>;
});
console.assert(scope.counter === <span class="number">1</span>); //<span class="literal">true</span>
</code></pre><h2 id="版本10:延迟执行函数实现。">版本10:延迟执行函数实现。</h2><p>在Javascript中要是用到延迟函数可以使用setTimeOut();我们要在$digest()后执行一个函数，这时我们打算自己实现一个队列，来存放要执行的函数，当满足条件后执行队列中的这个函数$evalAsync（），当$digest()函数执行后条件成立。回调asyncQueue 数组中的函数，函数的名字，仅仅是一个变量而已。</p>
<p>首先创建一个队列存放函数：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];／／队列存放 函数
}
</code></pre><p>自己可以使用firebug跟一下这个函数，当$digest()，当条件满足时执行队列中的函数，这就实现了延迟，在$digest()后执行就是延迟，在$digest()执行前就是提前执行：</p>
<pre><code>Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {//条件
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);／／回调函数
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};
</code></pre><p>完整代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
}

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {//<span class="variable">$digest</span>()执行前while的条件为false，
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  this.$<span class="variable">$asyncQueue</span>.push({scope: this, expression: expr});
};
</code></pre><p>测试：提示（firebug 一步一的看一遍就明白了）</p>
<pre><code>var <span class="keyword">scope</span> = <span class="keyword">new</span> Scope();
<span class="keyword">scope</span>.asyncEvaled = <span class="literal">false</span>;

<span class="keyword">scope</span>.$watch(
  <span class="built_in">function</span>(<span class="keyword">scope</span>) {
    <span class="keyword">return</span> <span class="keyword">scope</span>.aValue;
  },
  <span class="built_in">function</span>(newValue, oldValue, <span class="keyword">scope</span>) {
    <span class="keyword">scope</span>.counter++;
    <span class="keyword">scope</span>.$evalAsync(<span class="built_in">function</span>(<span class="keyword">scope</span>) { <span class="comment">//  回调函数执行这段代码</span>
      <span class="keyword">scope</span>.asyncEvaled = <span class="literal">true</span>;
    });
    console.log(<span class="string">"Evaled inside listener: "</span>+<span class="keyword">scope</span>.asyncEvaled);／／ 这段代码 输出<span class="string">"Evaled inside listener: false"</span> ；因为这段代码执行的时候，回调函数并没有执行,使用队列和回调函数实现延迟。可以使用firebug 进行观察。
  }
);

<span class="keyword">scope</span>.aValue = <span class="string">"test"</span>;
<span class="keyword">scope</span>.$digest();
console.log(<span class="string">"Evaled after digest: "</span>+<span class="keyword">scope</span>.asyncEvaled);  ／／输出 <span class="literal">true</span>
</code></pre><h2 id="版本11:修复版本10中的一个bug，当两个$digest同时执行时会对公共变量this-$$asyncQueue_=_[]造成影响，只要$asyncQueue[]长度不为0，第二个$digest()遇到while循环的时候就会执行。所以添加一个标志位this-$$phase_当它不为null的时候就抛出一个异常，证明有函数正在执行，确保时单线程的。">版本11:修复版本10中的一个bug，当两个$digest同时执行时会对公共变量this.$$asyncQueue = []造成影响，只要$asyncQueue[]长度不为0，第二个$digest()遇到while循环的时候就会执行。所以添加一个标志位this.$$phase 当它不为null的时候就抛出一个异常，证明有函数正在执行，确保时单线程的。</h2><pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};
</code></pre><p>测试：</p>
<pre><code>var <span class="keyword">scope</span> = <span class="keyword">new</span> Scope();
<span class="keyword">scope</span>.asyncEvaled = <span class="literal">false</span>;

<span class="keyword">scope</span>.$evalAsync(<span class="built_in">function</span>(<span class="keyword">scope</span>) {
  <span class="keyword">scope</span>.asyncEvaled = <span class="literal">true</span>;
});

setTimeout(<span class="built_in">function</span>() {
  console.log(<span class="string">"Evaled after a while: "</span>+<span class="keyword">scope</span>.asyncEvaled);
}, <span class="number">100</span>); <span class="comment">//     延迟执行，确保digest函数可以运行</span>
</code></pre><p>版本12：在$deigest后执行的函数 - $$postDigest,这个函数有两个$$符号，证明我们的应用时不能调用这个函数的，这个函数会在$digest满足while条件后立即执行。</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$postDigestQueue</span> = []; // 新增的延迟函数
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    var newValue = watch.watchFn(self);
    var oldValue = watch.last;
    if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
      watch.listenerFn(newValue, oldValue, self);
      dirty = true;
      watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
      this.<span class="variable">$eval</span>(asyncTask.expression);
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    this.$<span class="variable">$postDigestQueue</span>.shift()();
  }
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};

Scope.prototype.$<span class="variable">$postDigest</span> = <span class="keyword">function</span>(fn) {
  this.$<span class="variable">$postDigestQueue</span>.push(fn);
};
</code></pre><p>测试：</p>
<pre><code>var scope = new Scope();
var postDigestInvoked = <span class="literal">false</span>;

scope.$<span class="variable">$postDigest</span>(<span class="keyword">function</span>() { // 往数组里面存值
  postDigestInvoked = true;
});

console.assert(!postDigestInvoked);

scope.<span class="variable">$digest</span>();
console.assert(postDigestInvoked);
</code></pre><h2 id="版本12:异常处理添加_try_catch_使函数变的跟健壮，处理_$evalAsync_function,_或者_$$postDigest带来的异常">版本12:异常处理添加 try  catch 使函数变的跟健壮，处理 $evalAsync function, 或者  $$postDigest带来的异常</h2><pre><code>Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      try {&lt;!--包裹异常--&gt;
        var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
        this.<span class="variable">$eval</span>(asyncTask.expression);
      } catch (e) {
        (console.error || console.log)(e);
      }
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    try {&lt;!--包裹异常--&gt;
      this.$<span class="variable">$postDigestQueue</span>.shift()();
    } catch (e) {
      (console.error || console.log)(e);
    }
  }
};
</code></pre><p>完整的测试代码如下，会制造异常，用来测试：</p>
<pre><code>    <span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$postDigestQueue</span> = [];
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() {},
    valueEq: !!valueEq
  };
  this.$<span class="variable">$watchers</span>.push(watcher);
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    try {
      var newValue = watch.watchFn(self);
      var oldValue = watch.last;
      if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
        watch.listenerFn(newValue, oldValue, self);
        dirty = true;
        watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
      }
    } catch (e) {
      (console.error || console.log)(e);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      try {
        var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
        this.<span class="variable">$eval</span>(asyncTask.expression);
      } catch (e) {
        (console.error || console.log)(e);
      }
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    try {
      this.$<span class="variable">$postDigestQueue</span>.shift()();
    } catch (e) {
      (console.error || console.log)(e);
    }
  }
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};

Scope.prototype.$<span class="variable">$postDigest</span> = <span class="keyword">function</span>(fn) {
  this.$<span class="variable">$postDigestQueue</span>.push(fn);
};
</code></pre><p>测试：<!--抛出异常后函数正常执行--></p>
<pre><code>var scope = new Scope();
scope.aValue = <span class="string">"abc"</span>;
scope.counter = <span class="number">0</span>;

scope.<span class="variable">$watch</span>(<span class="keyword">function</span>() {
  throw <span class="string">"Watch fail"</span>;
});
scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    scope.<span class="variable">$evalAsync</span>(function(scope) {
      throw <span class="string">"async fail"</span>;
    });
    return scope.aValue;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

scope.<span class="variable">$digest</span>(); 
console.assert(scope.counter === <span class="number">1</span>);
</code></pre><h2 id="版本13:移除watch函数中的对象，即销毁对象，用到了闭包，改造$watch函数，如果只是初始化定义$watch函数，watch函数中的return函数时不会执行的。">版本13:移除watch函数中的对象，即销毁对象，用到了闭包，改造$watch函数，如果只是初始化定义$watch函数，watch函数中的return函数时不会执行的。</h2><pre><code>Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var self = this;
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn,
    valueEq: !!valueEq
  };
  self.$<span class="variable">$watchers</span>.push(watcher);
  return function() {
    var index = self.$<span class="variable">$watchers</span>.indexOf(watcher);
    if (index &gt;= <span class="number">0</span>) {
      self.$<span class="variable">$watchers</span>.splice(index, <span class="number">1</span>);
    }
  };
};
</code></pre><p>终极代码如下：</p>
<pre><code><span class="keyword">function</span> Scope() {
  this.$<span class="variable">$watchers</span> = [];
  this.$<span class="variable">$asyncQueue</span> = [];
  this.$<span class="variable">$postDigestQueue</span> = [];
  this.$<span class="variable">$phase</span> = null;
}

Scope.prototype.<span class="variable">$beginPhase</span> = <span class="keyword">function</span>(phase) {
  if (this.$<span class="variable">$phase</span>) {
    throw this.$<span class="variable">$phase</span> + <span class="string">' already in progress.'</span>;
  }
  this.$<span class="variable">$phase</span> = phase;
};

Scope.prototype.<span class="variable">$clearPhase</span> = <span class="keyword">function</span>() {
  this.$<span class="variable">$phase</span> = null;
};

Scope.prototype.<span class="variable">$watch</span> = <span class="keyword">function</span>(watchFn, listenerFn, valueEq) {
  var self = this;
  var watcher = {
    watchFn: watchFn,
    listenerFn: listenerFn || function() { },
    valueEq: !!valueEq
  };
  self.$<span class="variable">$watchers</span>.push(watcher);
  return function() {
    var index = self.$<span class="variable">$watchers</span>.indexOf(watcher);
    if (index &gt;= <span class="number">0</span>) {
      self.$<span class="variable">$watchers</span>.splice(index, <span class="number">1</span>);
    }
  };
};

Scope.prototype.$<span class="variable">$areEqual</span> = <span class="keyword">function</span>(newValue, oldValue, valueEq) {
  if (valueEq) {
    return <span class="number">_</span>.isEqual(newValue, oldValue);
  } else {
    return newValue === oldValue ||
      (typeof newValue === <span class="string">'number'</span> &amp;&amp; typeof oldValue === <span class="string">'number'</span> &amp;&amp;
       isNaN(newValue) &amp;&amp; isNaN(oldValue));
  }
};

Scope.prototype.$<span class="variable">$digestOnce</span> = <span class="keyword">function</span>() {
  var self  = this;
  var dirty;
  <span class="number">_</span>.forEach(this.$<span class="variable">$watchers</span>, function(watch) {
    try {
      var newValue = watch.watchFn(self);
      var oldValue = watch.last;
      if (!self.$<span class="variable">$areEqual</span>(newValue, oldValue, watch.valueEq)) {
        watch.listenerFn(newValue, oldValue, self);
        dirty = true;
        watch.last = (watch.valueEq ? <span class="number">_</span>.cloneDeep(newValue) : newValue);
      }
    } catch (e) {
      (console.error || console.log)(e);
    }
  });
  return dirty;
};

Scope.prototype.<span class="variable">$digest</span> = <span class="keyword">function</span>() {
  var ttl = <span class="number">10</span>;
  var dirty;
  this.<span class="variable">$beginPhase</span>(<span class="string">"$digest"</span>);
  do {
    while (this.$<span class="variable">$asyncQueue</span>.length) {
      try {
        var asyncTask = this.$<span class="variable">$asyncQueue</span>.shift();
        this.<span class="variable">$eval</span>(asyncTask.expression);
      } catch (e) {
        (console.error || console.log)(e);
      }
    }
    dirty = this.$<span class="variable">$digestOnce</span>();
    if (dirty &amp;&amp; !(ttl--)) {
      this.<span class="variable">$clearPhase</span>();
      throw <span class="string">"10 digest iterations reached"</span>;
    }
  } while (dirty);
  this.<span class="variable">$clearPhase</span>();

  while (this.$<span class="variable">$postDigestQueue</span>.length) {
    try {
      this.$<span class="variable">$postDigestQueue</span>.shift()();
    } catch (e) {
      (console.error || console.log)(e);
    }
  }
};

Scope.prototype.<span class="variable">$eval</span> = <span class="keyword">function</span>(expr, locals) {
  return expr(this, locals);
};

Scope.prototype.<span class="variable">$apply</span> = <span class="keyword">function</span>(expr) {
  try {
    this.<span class="variable">$beginPhase</span>(<span class="string">"$apply"</span>);
    return this.<span class="variable">$eval</span>(expr);
  } finally {
    this.<span class="variable">$clearPhase</span>();
    this.<span class="variable">$digest</span>();
  }
};

Scope.prototype.<span class="variable">$evalAsync</span> = <span class="keyword">function</span>(expr) {
  var self = this;
  if (!self.$<span class="variable">$phase</span> &amp;&amp; !self.$<span class="variable">$asyncQueue</span>.length) {
    setTimeout(function() {
      if (self.$<span class="variable">$asyncQueue</span>.length) {
        self.<span class="variable">$digest</span>();
      }
    }, <span class="number">0</span>);
  }
  self.$<span class="variable">$asyncQueue</span>.push({scope: self, expression: expr});
};

Scope.prototype.$<span class="variable">$postDigest</span> = <span class="keyword">function</span>(fn) {
  this.$<span class="variable">$postDigestQueue</span>.push(fn);
};


var scope = new Scope();
scope.aValue = <span class="string">"abc"</span>;
scope.counter = <span class="number">0</span>;
&lt;!--初始化watch函数--&gt;
var removeWatch = scope.<span class="variable">$watch</span>(
  <span class="keyword">function</span>(scope) {
    return scope.aValue;
  },
  <span class="keyword">function</span>(newValue, oldValue, scope) {
    scope.counter++;
  }
);

scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">1</span>);

scope.aValue = <span class="string">'def'</span>;
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>);
&lt;!--调用watch函数，移除上一个元素--&gt;
removeWatch();
scope.aValue = <span class="string">'ghi'</span>;
scope.<span class="variable">$digest</span>();
console.assert(scope.counter === <span class="number">2</span>); // <span class="literal">true</span>,不是<span class="number">3</span>
</code></pre><p>要检验一个知识点，所学是否透彻，最直接的方式就时造轮子，Angular的核心代码有1万4千多行，看起来还是挺费劲的。博客里的这篇文章参考了：<a href="http://teropa.info/build-your-own-angular" target="_blank" rel="external">Build Your Own AngularJS</a>，感谢作者的分享，为止见过最好的一本讲解 Angular原理的一本书，Angular中虽然有很多坑（自己学艺不精）但是依然是个非常优秀的框架，在平时的项目中一步步填坑，验证一句老话，实践时最好的老师。</p>

      
    </div>
    <footer class="article-footer">
      <!--<a data-url="http://yoursite.com/2015/11/20/自己实现Angualrjs脏数据监测/" data-id="cihdf0s8g0003r8krzrnlc82t" class="article-share-link">Share</a>-->
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/AngularJS/">AngularJS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2015/11/08/Angular-Js-Controller/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Angular js 两个Controller之间通信</div>
    </a>
  
</nav>

  
</article>



<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-自己实现Angualrjs脏数据监测" data-title="实现Angualrjs脏数据监测" data-url="http://yoursite.com/2015/11/20/自己实现Angualrjs脏数据监测/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
    var duoshuoQuery = {short_name:'junsoft'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->
</section>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近博客</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2015/11/20/自己实现Angualrjs脏数据监测/">实现Angualrjs脏数据监测</a>
          </li>
        
          <li>
            <a href="/blog/2015/11/08/Angular-Js-Controller/">Angular js 两个Controller之间通信</a>
          </li>
        
          <li>
            <a href="/blog/2015/11/07/Mac下搭建Hexo/">Mac下搭建Hexo</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2015/11/">十一月 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/Angular/" style="font-size: 10px;">Angular</a> <a href="/blog/tags/AngularJS/" style="font-size: 10px;">AngularJS</a> <a href="/blog/tags/Hexo博客搭建/" style="font-size: 10px;">Hexo博客搭建</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 苍晨<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
       

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/blog/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>